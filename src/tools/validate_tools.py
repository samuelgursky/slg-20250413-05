#!/usr/bin/env python3
"""
Tool Registration Validation Script

This script validates that all tool registrations in the MCP server match their 
actual function implementations.
"""

import os
import sys
import argparse
import logging
from typing import Dict, Any, List, Optional, Tuple

# Add parent directory to path so we can import modules
script_dir = os.path.dirname(os.path.abspath(__file__))
src_dir = os.path.dirname(script_dir)
if src_dir not in sys.path:
    sys.path.append(src_dir)

from tools.validation import validate_tool_parameters, print_validation_errors, fix_tool_parameters
from tools.registration import TOOLS_REGISTRY

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)

logger = logging.getLogger("validate_tools")

def write_fixes_to_file(fixed_registry: Dict[str, Dict[str, Any]], output_file: str) -> None:
    """
    Write fixed registry entries to a Python file
    
    Args:
        fixed_registry: The corrected tool registry
        output_file: Path to the output file
    """
    with open(output_file, 'w') as f:
        f.write('"""Fixed Tool Registration Entries\n')
        f.write('This file contains corrected tool registration entries generated by the validation tool.\n')
        f.write('"""\n\n')
        f.write('# Format: tool_name: { "parameters": [...] }\n')
        f.write('FIXED_ENTRIES = {\n')
        
        # Sort for consistent output
        for tool_name in sorted(fixed_registry.keys()):
            tool_info = fixed_registry[tool_name]
            if "parameters" not in tool_info:
                continue
                
            f.write(f'    "{tool_name}": {{\n')
            f.write('        "parameters": [\n')
            
            for param in tool_info["parameters"]:
                f.write('            {\n')
                for key, value in param.items():
                    if isinstance(value, str):
                        f.write(f'                "{key}": "{value}",\n')
                    else:
                        f.write(f'                "{key}": {value},\n')
                f.write('            },\n')
                
            f.write('        ]\n')
            f.write('    },\n')
            
        f.write('}\n')

def main():
    parser = argparse.ArgumentParser(description='Validate tool parameter registrations against function signatures.')
    parser.add_argument('--fix', action='store_true', help='Generate fixed parameter registrations')
    parser.add_argument('--output', type=str, default='fixed_tool_entries.py', 
                      help='Output file for fixed entries (default: fixed_tool_entries.py)')
    args = parser.parse_args()
    
    # Validate all tools
    logger.info("Validating tool registrations against function signatures...")
    validation_errors = validate_tool_parameters(TOOLS_REGISTRY)
    
    # Print errors
    if validation_errors:
        print_validation_errors(validation_errors)
        logger.info(f"Found {len(validation_errors)} validation issues.")
        
        error_count = sum(1 for e in validation_errors if e.get("severity") in ["error", "critical"])
        warning_count = len(validation_errors) - error_count
        
        logger.info(f"Errors: {error_count}, Warnings: {warning_count}")
    else:
        logger.info("No validation issues found. All tool registrations match function signatures.")
        
    # Generate fixes if requested
    if args.fix and validation_errors:
        logger.info(f"Generating fixed parameter registrations to {args.output}...")
        fixed_registry = fix_tool_parameters(TOOLS_REGISTRY)
        write_fixes_to_file(fixed_registry, args.output)
        logger.info(f"Fixed entries written to {args.output}")
    
    # Return error count for shell scripting
    return 1 if validation_errors else 0

if __name__ == "__main__":
    sys.exit(main()) 